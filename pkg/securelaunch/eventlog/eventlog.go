package eventlog

import (
	"fmt"
	"log"
	"strings"

	"github.com/9elements/tpmtool/pkg/tpm"
	"github.com/u-root/u-root/pkg/mount"
	slaunch "github.com/u-root/u-root/pkg/securelaunch"
)

/* describes the "eventlog" section of policy file */
type EventLog struct {
	Type     string `json:"type"`
	Location string `json:"location"`
}

const (
	eventLogFile        = "/sys/kernel/security/slaunch/eventlog"
	defaultEventLogFile = "eventlog.txt" //only used if user doesn't provide any
)

/*
 * event logs are generated by the kernel with CONFIG_SECURE_LAUNCH enabled.
 * these event logs are in binary format and need to be parsed into human readable
 * format. This is acheived by tpmtool pkg.
 * parseEvtLog() fn uses tpmtool to parse the eventlog generated by
 * kernel at location "eventLogFile" and the result in returned in a byte slice.
 * returns
 * - error if parsing code fails in tpmtool.
 */
func parseEvtLog(evtLogFile string) ([]byte, error) {

	tpm.DefaultTCPABinaryLog = evtLogFile
	firmware := tpm.Txt
	TPMSpecVersion := tpm.TPM20
	tcpaLog, err := tpm.ParseLog(firmware, TPMSpecVersion)
	if err != nil {
		return nil, err
	}

	var w strings.Builder
	for _, pcr := range tcpaLog.PcrList {
		fmt.Fprintf(&w, "%s\n", pcr)
		fmt.Fprintf(&w, "\n")
	}
	return []byte(w.String()), nil
}

/*
 * After tpmtool parses event logs, generated by the kernel, into human readable
 * format, we store the result in a file on disk.
 * The location of the file on disk is specified in policy file by Location tag.
 * returns
 * - error if mounting the disk fails __OR_ writing to location on disk fails.
 */
func (e *EventLog) Persist() error {

	if e.Type != "file" {
		return fmt.Errorf("EventLog: Unsupported eventlog type. Exiting.")
	}

	slaunch.Debug("Identified EventLog Type = file")

	// e.Location is of the form sda:path/to/file.txt
	eventlogPath := e.Location
	if eventlogPath == "" {
		return fmt.Errorf("EventLog: Empty eventlog path. Exiting.")
	}

	filePath, mountPath, r := slaunch.GetMountedFilePath(eventlogPath, true) // true = rw mount option
	if r != nil {
		return fmt.Errorf("EventLog: ERR: input %s could NOT be located, err=%v", eventlogPath, r)
	}

	dst := filePath // /tmp/boot-733276578/evtlog

	// parse eventlog
	data, err := parseEvtLog(eventLogFile)
	if err != nil {
		log.Printf("tpmtool could NOT parse Eventlogfile=%s, err=%s", eventLogFile, err)
		return fmt.Errorf("EventLog(): Persist() err=%v", err)
	}

	// write parsed data onto disk
	target, err := slaunch.WriteToFile(data, dst, defaultEventLogFile)
	if ret := mount.Unmount(mountPath, true, false); ret != nil {
		log.Printf("Unmount failed. PANIC")
		panic(ret)
	}

	if err != nil {
		log.Printf("EventLog: Write err=%v, dst=%s, exiting", err, dst)
		return fmt.Errorf("EventLog: Write err=%v, dst=%s, exiting", err, dst)
	}

	slaunch.Debug("EventLog: success, data written to %s", target)
	return nil
}
